# Git Strategy (Initial Hypothesis)

The following table serves as a guide for our team's collaboration, outlining three levels of Git usage that we can navigate based on the project's current needs and technical complexity.

| Level | Strategy Name | Initial Educated Guess: Use Case | Navigating the "Unknowns" | Effort Estimation |
| :--- | :--- | :--- | :--- | :--- |
| **Level 1** | **Direct Push** | **Assumption:** Best for the early phase. We might use this for most of the project to keep things moving fast. | **Indicator to stay here:** As long as we are communicating well verbally and the code is simple enough that we don't lose track of tasks. | **Low:** The standard add, commit, push workflow. |
| **Level 2** | **Hybrid** | **Assumption:** We might try this once we have specific features to divide (2rd, 3rd, 4th variable models). | **Indicator to move here:** If we start asking, *"Which research paper was this logic for?"*â€”Issues provide the missing "paper trail" for the research. | **Medium:** Creating a web issue + typing #ID in your commit. |
| **Level 3** | **Pull Requests** | **Assumption:** We might reserve this for the final "Publication-Ready" graph code as a final safety check. | **Indicator to move here:** If we are 90% done and want to ensure a "clean" final version for submission without risking a last-minute break. | **High:** Managing branches and approvals on GitHub. |